<h1>1.5 Прочие модификаторы (nonaccess modifiers)</h1>

<p>В этом уроке мы рассмотрим такие модификаторы как <em>abstract</em>, <em>final</em>, <em>static</em>.
  Если модификаторы доступа контролируют видимость классов и их членов за пределами класса и/или пакета,
  то прочие модификаторы служат для изменения поведение класса или его членов по умолчанию .</p>
<p>К примеру, если вы добавите модификатор <em>abstract </em>при определении класса, то создать его экземпляр будет невозможно.</p>
<p>При определении ваших классов, интерфейсов, методов и переменных вы можете использовать следующие модификаторы:</p>
<ul class="list">
	<li><em>abstract</em></li>
	<li><em>static</em></li>
	<li><em>final</em></li>
	<li><em>synchronized</em></li>
	<li><em>native</em></li>
	<li><em>strictfp</em></li>
	<li><em>transient</em></li>
	<li><em>volatile</em></li>
</ul>
<p>Вопросы в экзамене затрагивают только 3 из них (<em>abstract</em>, <em>final</em>, <em>statiс</em>),
  поэтому мы рассматрим детально только их. Но если остальные модификаторы вам не знакомы, вот краткое их описание:</p>
<ul class="list">
	<li> <em>synchronized </em>&ndash; методы с данным модификатором не могут быть одновременно вызваны несколькими потоками (<em>threads</em>) в многопоточном приложении.
    Данный модификатор<s> не применим</s> к классам, интерфейсам и переменным;</li>
	<li><em>native </em>&ndash; <em>native</em>-методы нужны для вызова и использования библиотек и методов,
    имплементированных из других языков программирования таких как <em>C</em> и <em>C++</em>.
    <s>Не применим</s> к классам, интерфейсами и переменными;</li>
	<li><em>transient </em>&ndash; <em>transient</em>-переменные не сериализуются при сериализации объекта,
    в котором они находятся. <s>Не применим</s> к классам, интерфейсам и методам;</li>
	<li><em>volatile </em>&ndash; <em>volatile</em>-переменные могут безопасно использоваться несколькими потоками при многопоточности.
    <s>Не применим </s>к классам, интерфейсам и методам;</li>
	<li><em>strictfp </em>&ndash; определенные с этим модификатором классы,
    интерфейсы и методы обеспечивают идентичность выполнения операций с плавающей точкей на всех платформах.
    <s>Не используется</s> с переменными.</li>
</ul>
<p>А теперь рассмотрим модификаторы, которые будут в вопросах экзамена.</p>
<hr />

<h2>1.5.1 Модификатор abstract</h2>
<p>При добавлении модификатора <em>abstract </em>к определению класса, интерфейса или метода, он меняет только его поведение по умолчанию, но не его доступность.</p>
<hr />

<h3>Абстрактный класс</h3>
<p>При добавлении слова <em>abstract </em>перед определением конкретного класса, класс превращается в абстрактный,
  даже если в классе нет не одного абстрактного метода. Ниже представлен пример абстрактного класса:</p>
<div class="code-block">
  <p>abstract class Cat{</p>
  <p>private String name;</p>
  <p style="margin-left:40px">public void callCat(){}</p>
  <p>}</p>
</div>
<p>Создать экземпляр абстрактного класса нельзя, при попытке это сделать вы получите ошибку компиляции:</p>
<div class="code-block">
  <p>class Pets{</p>
  <p style="margin-left:40px">Cat cat = new Cat(); //на этой строчке мы <s>получим ошибку компиляции</s></p>
  <p>}</p>
</div>
<p>Ошибка будет выглядеть следующим образом:</p>
<div class="console-block">
  <p>University.java:2: Cat is abstract; cannot be instantiated</p>
  <p>Cat cat = new Cat();</p>
</div>
<div class="remember">
<p><strong>Абстрактный класс может или не может содержать абстрактных методов.
  Но класс, не обозначенный данным модификатором, не может содержать абстрактных методов.</strong></p>
</div>
<hr />

<h3>Абстрактные интерфейсы</h3>
<p>Интерфейсы являются абстрактными по умолчанию. Java-компилятор автоматически добавляет данный модификатор к определению интерфейса.
  Поэтому добавление к определению интерфейса слова <em>abstract </em>является излишним (<s>но не является ошибкой</s>).
  Представленные ниже примеры стаовятся идентичными после компиляции:</p>
<div class="code-block">
  <p>interface Dog(){}</p>
  <p>abstract interface Dog(){}</p>
</div>
<hr />

<h3>Абстрактные методы</h3>
<p>У абстрактного метода нет тела (<em>body</em>). Обычно абстрактные методы реализуются в наследующихся классах. Ниже представлен пример:</p>
<div class="code-block">
  <p>abstract class Cat {</p>
  <p style="margin-left:40px">private String name;</p>
  <p style="margin-left:40px">public void sayHi() { } //это не абстрактный метод, а метод с пустым телом</p>
  <p style="margin-left:40px">public abstract void comeTo(); //это абстрактный метод (у него отсутствует тело {})</p>
  <p>}</p>
</div>
<div class="remember">
<p><strong>Метод с пустым телом не является абстрактным.</strong></p>
</div>
<hr />

<h3>Абстрактные переменные</h3>
<p>Не одна из стандартных типов переменных (принадлежащих экземпляру, статическая, локальная или параметр метода)
  не может быть определена с модификатором <em>abstract</em>.</p>
<div class="remember">
<p><strong>Не дайте ввести себя в заблуждение вопросам в экзамене, когда увидите переменную с модификатором <em>abstract</em>.
  Данный код не скомпилируется.</strong></p>
</div>
<hr />

<h2>1.5.2 Модификатор final</h2>
<p>Модификатор <em>final </em>может использоваться при определении классов, переменных и методов.
  С интерфейсами этот модификатор не используется (если вы конечно не хотите получить <s>ошибку компиляции</s>).</p>
<hr />

<h2>Финальный класс</h2>
<p>От класса, помеченного модификатором <em>final </em>нельзя наследоваться.</p>
<p>Класс <em>Cat </em>не скомпилируется, если класс <em>Pet </em>будет помечен модификатором <em>final</em>:</p>
<div class="code-block">
  <p>final class Pet{}</p>
  <p>class Cat extends Pet{}<s> //ошибка компиляции</s></p>
</div>
<hr />

<h3>Финальная переменная</h3>
<p>Значение финальных переменных нельзя изменить. Задать значение можно только один раз. Пример ниже:</p>
<div class="code-block">
<p>class Cat {</p>
  <p style="margin-left:40px">final long MAX_HEIGHT;</p>
  <p style="margin-left:40px">Cat () {</p>
  <p style="margin-left:80px">MAX_HEIGHT = 35; <s>//все компилируется без ошибок</s></p>
  <p style="margin-left:40px">}</p>
  <p>}</p>
</div>
<p>Если изменить код выше следующим образом, то мы уже получим ошибку компиляции:</p>
<div class="code-block">
  <p>class Cat {</p>
  <p style="margin-left:40px">final long MAX_HEIGHT = 150; <s>//задали значение</s></p>
  <p style="margin-left:40px">Cat () {</p>
  <p style="margin-left:80px">MAX_HEIGHT = 35; <s>//ошибка компиляции, </s>т.к. это попытка задать новое значение</p>
  <p style="margin-left:40px">}</p>
  <p>}</p>
</div>
<p>Изменение значения ссылочной переменной можно легко спутать с вызовом метода переменной,
  которая изменяет состояние объекта, на который она ссылается.
  Запомните, что если ссылочной переменной задать неизменяемую ссылку на объект,
  то вы не сможете поменять эту ссылку,
  но вызывать методы данного объекта вы можете без проблем (при этом может меняться и его состояние):</p>
<div class="code-block">
  <p>class Cat {</p>
  <p style="margin-left:40px">final StringBuilder name = new StringBuilder(&quot;Best&quot;);</p>
  <p style="margin-left:40px">Cat() {</p>
  <p style="margin-left:80px">name.append(&quot; of the best&quot;); <s>//вызов метода объекта допустим</s></p>
  <p style="margin-left:80px">name = new StringBuilder(); <s>// при попытке изменения ссылки, получим ошибку компиляции</s></p>
  <p style="margin-left:40px">}</p>
  <p>}</p>
</div>
<hr />

<h3>Финальный метод</h3>
<p>Финальные методы нельзя переопределять в классах-наследниках:</p>
<div class="code-block">
  <p>class Pet {</p>
  <p style="margin-left:40px">final void say() {</p>
  <p style="margin-left:80px">System.out.println(&quot;Myyyyy&quot;);</p>
  <p style="margin-left:40px">}</p>
  <p>}</p>
  <p>class Cat extends Pet {</p>
  <p style="margin-left:40px">void say () { <s>//ошибка компиляции</s></p>
  <p style="margin-left:80px">System.out.println(&quot;Meow&quot;);</p>
  <p style="margin-left:40px">}</p>
  <p>}</p>
</div>
<div class="info">
  <p><strong>Если метод в наследующемся классе имеет такую же сигнатуру как и родительский класс,
    то такой метод называется переопределенным методом.
    Детально переопределение мы рассмотрим в блоке 6</strong></p>
</div>
<hr />

<h2>1.5.3 Модификатор static</h2>
<p>Модификатор <em>static </em>может быть применен к классам, интерфейсам, методам и переменным. Рассмотрим их всех поотдельности.</p>
<hr />

<h3>Статические переменные</h3>
<p>Статические переменные принадлежат классу. Они общие для всех экземпляров класса.
  Статические переменные существуют независимо от того, создан ли экземпляр класса или нет.</p>
<p>Примером статической переменной в жизни может быть общий холодильник в столовой офиса для сотрудников отдельного этажа.
  Каждый работник с 1го этажа пользуется одним и тем же холодильником №1, 2го - №2 и т.д., и,
  если кто-то что-то берет или кладет в холодильник, то все остальные работники видят изменения в холодильнике.</p>
<div class="code-block">
  <p>class Employee{</p>
  <p style="margin-left:40px">String name;</p>
  <p style="margin-left:40px">static int refrigerator; //каждый сотрудник <s>может пользоваться</s> одним холодильником</p>
  <p>}</p>
</div>
<p>Чтобы продемонстрировать то, что статическая переменная является общей для всех объектов и,
  при изменении в одном классе, она изменяется во всех, ниже приведен следующий код:</p>
<div class="code-block">
  <p>class Test{</p>
  <p style="margin-left:40px">Employee emp1 = new Employee();</p>
  <p style="margin-left:40px">Employee emp2 = new Employee();</p>
  <p style="margin-left:40px">emp1.refrigerator = 1;</p>
  <p style="margin-left:40px">emp1.refrigerator = 5;</p>
  <p style="margin-left:40px">System.out.println(emp1.refrigerator); // в консоль выведиться <s>&laquo;5&raquo;</s></p>
  <p style="margin-left:40px">System.out.println(emp1.refrigerator); // в консоль опять выведиться <s>&laquo;5&raquo;</s></p>
  <p style="margin-left:40px">System.out.println(Employee.refrigerator); // в консоль выведиться опять-таки <s>&laquo;5&raquo;</s></p>
  <p>}</p>
</div>
<p>В приведенном выше коде <em>emp1.refrigerator, emp1.refrigerator</em> и <em>Employee.refrigerator</em>
  ссылаются на одну и ту же статическую переменную <em>refrigerator</em>.</p>
<p>Несмотря на то, что вы можете использовать статическую переменную используя ссылку на объект
  (<em>emp1.refrigerator</em>), делать это не рекомендуется потому, что это может ввести в заблуждение тех,
  кто будет читать ваш код &ndash; может сложиться впечатление, что вызывается не статическая переменная,
  а переменная, принадлежащая конкретному объекту.
  Поэтому рекомендуется использовать статические переменные с именем класса (<em>Employee.refrigerator</em>).</p>
<p>В случае, когда вы используете вместе модификаторы <em>final </em>и <em>static </em>
  при объявлении переменных вы получаете <s>константы </s>(переменные, которые нельзя изменить).</p>
<p>В коде ниже в классе <em>Car </em>мы определяем две константы: <em>MAX_SPEED</em> и <em>MAX_WEIGHT</em>:</p>
<div class="code-block">
  <p>class Car{</p>
  <p style="margin-left:40px">public static final int MAX_SPEED = 700;</p>
  <p style="margin-left:40px">static final int  MAX_WEIGHT = 15000;</p>
  <p>}</p>
</div>
<p>При объявлении констант вы можете не делать их статическими,
  но в мировой практике используется именно <em>static final</em>,
  т.к. это позволяет использовать константы, не привязывая их к конкретному объекту.</p>
<hr />

<h3>Статические методы</h3>
<p>Статические методы не связаны с объектами класса и не могут использовать переменные отдельного экземпляра класса.
  В статических методах допускается использовать только статические переменные класса:</p>
<div class="code-block">
  <p>class Car{</p>
  <p style="margin-left:40px">String model;</p>
  <p style="margin-left:40px">static int price;</p>
  <p style="margin-left:40px">static int getPrice(){</p>
  <p style="margin-left:80px">return price;</p>
  <p style="margin-left:40px">}</p>
  <p>}</p>
</div>
<p>Часто статические методы используют для создания <s>служебных методов</s>,
  которые обычно производят операции только над параметрами, передаваемыми в метод, и возвращают обработанное значение:</p>
<div class="code-block">
  <p>static int sum(int one, int two){</p>
  <p style="margin-left:40px">return one + two;</p>
  <p>}</p>
</div>
<p>Статические методы могут быть унаследованы в производных классах.
  Но к ним не применимо понятие <s>полиморфизм </s>
  (возможность применения одноименных методов с одинаковыми или различными наборами параметров в одном классе или в группе классов,
  связанных отношением наследования.) Вы не можете переопределить метод из родительского класса в привычном понимании,
  если в дочернем классе вы создадите статический метод с такой же сигнатурой метод из родительского класса будет просто скрыт.</p>
  <hr/>

<h3>Кто имеет доступ к статическим методам?</h3>
<p>Статическим переменным и методам недоступны нестатические элементы класса.
  Но в то же время, нестатические элементы <s>могут </s>без проблем <s>использовать </s>статические потому,
  что статические члены классы существуют даже, если ни одного объекта класса не создано.</p>
<p>Рассмотрим пример:</p>
<div class="code-block">
  <p>class Test {</p>
  <p style="margin-left:40px">static int i = count(); /<s>/ошибка компиляции</s></p>
  <p style="margin-left:40px">int count() { return 10; }</p>
  <p>}</p>
</div>
<p>Мы получим следующую ошибку компиляции:</p>
<div class="console-block">
  <p>MyClass.java:3: nonstatic method count() cannot be referenced from a static</p>
  <p style="margin-left:40px">context</p>
  <p style="margin-left:40px">static int i = count();</p>
  <p style="margin-left:40px">1 error</p>
</div>
<p>Код ниже работает без ошибок:</p>
<div class="code-block">
  <p>class Test {</p>
  <p style="margin-left:40px">static int i = giveFive();</p>
  <p style="margin-left:40px">static int giveFive () { return 5; }</p>
  <p style="margin-left:40px">int nonStaticResult() { return giveFive(); }</p>
  <p>}</p>
</div>
<hr />

<p>Вызов статических членов из нулевой ссылки. (<em>NULL</em>)</p>
<p>Из-за того, что статические элементы принадлежат классу, а не его конкретному объекту,
  вы можете их вызвать используя ссылку, которая ссылается на <em>null</em>.</p>
<p><s>Будьте готовы </s>к такому вопросу в экзамене.
  Такие вызовы не приведут к ошибкам во время выполнения (<em>runtime exception</em>, если быть точно,
  то мы не получим <em>NullPointer-Exception</em>). Для примера рассмотрим следующий код:</p>
<div class="code-block">
  <p>class Lion {</p>
  <p style="margin-left:40px">String name;</p>
  <p style="margin-left:40px">static int cage;</p>
  <p style="margin-left:40px">static int getCage() {</p>
  <p style="margin-left:80px">return cage; //<s>возвращает 0</s></p>
  <p style="margin-left:40px">}</p>
  <p>}</p>

  <p>class Zoo {</p>
  <p style="margin-left:40px">public static void main(String[] args) {</p>
  <p style="margin-left:80px">Lion lion= null;</p>
  <p style="margin-left:80px">System.out.println(emp.cage); <s>// выведет в консоль 0</s></p>
  <p style="margin-left:80px">System.out.println(emp. getCage()); <s>// выведет в консоль 0</s></p>
  <p style="margin-left:40px">}</p>
  <p>}</p>
</div>
<hr />

<h3>Статические классы и интерфейсы</h3>
<p>Статические классы и интерфейсы являются вложенными классами, а, как уже говорилось ранее,
  в экзамене вложенные классы не затрагиваются. Но коротко расскажем несколько фактов о них.</p>
<p>Классы и интерфейсы высшего уровня <s>не могут быть </s>статическими. Примеры ниже не скомпилируются:</p>
<div class="code-block">
  <p>static class Pet{}</p>
  <p>static interface Cow{}</p>
</div>
<p>Но вы <s>можете объявить</s> статические вложенные классы:</p>
<div class="code-block">
  <p>class Zoo{</p>
  <p style="margin-left:40px">static class Pet{}</p>
  <p style="margin-left:40px">static interface Cow{}</p>
  <p>}</p>
</div>
